# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'WorkList.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import pandas as pd
import pic_1_rc
import sys
import os
import datetime
import csv
import sqlite3
import ctypes
import subprocess
import time
import Monitering.MainUI
import Monitering.SubUI
from Monitering.WorkList_db import WorkList_db_class

import MainUI
import SubUI
from WorkList_db import WorkList_db_class



class Singleton(type):  # Type을 상속받음
    __instances = {}  # 클래스의 인스턴스를 저장할 속성

    def __call__(cls, *args, **kwargs):  # 클래스로 인스턴스를 만들 때 호출되는 메서드
        if cls not in cls.__instances:  # 클래스로 인스턴스를 생성하지 않았는지 확인
            cls.__instances[cls] = super().__call__(*args, **kwargs)  # 생성하지 않았으면 인스턴스를 생성하여 해당 클래스 사전에 저장
            # print("인스턴스 생성 확인")
        # print("인스턴스 활용중 ~")
        # print(cls)
        return cls.__instances[cls]  # 클래스로 인스턴스를 생성했으면 인스턴스 반환


try:
    from watchdog.observers import Observer

    from watchdog.events import FileSystemEventHandler

except ModuleNotFoundError as e:
    print(e)
    os.system("pip install watchdog")


class Handler(FileSystemEventHandler):
    def on_created(self, event):  # 파일 생성시
        # Ui_MainWindow.temp_src = "A" #
        temp = event.src_path
        temp = temp.replace('\\', '/')  # 경로는 \\가 아닌 /로 치환

        DB.Inst_bcd_path(event.src_path)

        if event.is_directory:
            print("디렉토리 생성")
        else:  # not event.is_directory

            """
            Fname : 파일 이름
            Extension : 파일 확장자 
            """
            Fname, Extension = os.path.splitext(os.path.basename(event.src_path))
            '''
             1. zip 파일

             2. exe 파일

             3. lnk 파일

            '''
            # Extraction명이 들어간 경우는 화면 안나타게끔 예외처리
            temp = temp.find("Extraction")

            if Extension == '.txt':  # txt 파일만 추출
                if temp == -1:  # Extraction이 들어가지 않은 경우에만  화면 띄워주는 시그널을 1로 줌
                    Watcher.temp = 1
                    import shutil  # 파일을 다른곳에 백업 시켜둠.

                    shutil.copy(event.src_path, "C:\shinhoo\Monitering\Temp\\")  ########## 경

                    shutil.copy(event.src_path, "C:\\Barcode\\")  ########## 경



            elif Extension == '.exe':

                print(".exe 실행 파일 입니다.")

                os.remove(Fname + Extension)  # _파일 삭제 event 발생

    def on_deleted(self, event):

        print("삭제 이벤트 발생")

    def on_moved(self, event):  # 파일 이동시

        print("업데이트 이벤트 발생")


class Watcher(metaclass=Singleton):
    # 생성자
    temp = 0

    def __init__(self, path):
        self.event_handler = None  # Handler

        self.observer = Observer()  # Observer 객체 생성

        self.target_directory = path  # 감시대상 경로

        self.currentDirectorySetting()  # instance method 호출 func(1)

        # Ui_MainWindow.temp_src == "AA"

    # func (1) 현재 작업 디렉토리

    def currentDirectorySetting(self):
        print("현재 작업 디렉토리:  ", end=" ")

        os.chdir(self.target_directory)

        print("{cwd}".format(cwd=os.getcwd()))

    # func (2)

    def run(self):

        self.event_handler = Handler()  # 이벤트 핸들러 객체 생성

        self.observer.schedule(
            self.event_handler,
            self.target_directory,
            recursive=True

        )
        self.observer.start()  # 감시 시작
        try:

            while True:  # 무한 루프
                time.sleep(1)  # 1초 마다 대상 디렉토리 감시
                # self.observer.stop()  # 감시 중단
                break

        except KeyboardInterrupt:  # 사용자에 의해 "ctrl + z" 발생시

            print("감시 중지...")
            self.observer.stop()  # 감시 중단
            print("Error")
            self.observer.join()

    # 화면 불러오는 기능
    def Main(self):
        dialog_main = Monitering.MainUI.Ui_MainWindow()  # 배경화면 화면 객체생성
        dialog_sub = Monitering.SubUI.Ui_MainWindow()  # 바코드 비교화면 객체생성

        dialog_main = MainUI.Ui_MainWindow()  # 배경화면 화면 객체생성
        dialog_sub = SubUI.Ui_MainWindow()  # 바코드 비교화면 객체생성

        dialog_main.showFullScreen()  # 배경화면은 전체화면으로 띄워줌
        dialog_sub.exec_()  # 바코드 비교화면 실행
        dialog_sub.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)  # 비교화면을 가장 최상단으로 만들어줌.
        Watcher.temp = 0  # 화면 띄워주는 시그널 0으로 만들어 안뜨도록함.


if __name__ == "__main__":
    DB = WorkList_db_class()
    temp = 0

    PE_path = DB.show_PE_path()
    PE_path = PE_path[0][0]
    os.startfile(PE_path)
    import psutil  # 실행중인 프로세스 및 시스템 활용 라이브러리

    for proc in psutil.process_iter():
        try:
            # 프로세스 이름, PID값 가져오기
            processName = proc.name()
            processID = proc.pid

            if processName == "WorkList.exe":
                temp += 1
                parent_pid = processID  # PID
                parent = psutil.Process(parent_pid)  # PID 찾기
                if temp > 2:
                    for child in parent.children(recursive=True):  # 자식-부모 종료
                        child.kill()
                    parent.kill()

        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):  # 예외처리
            pass

    import sys
    import os

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    path1 = ""
    path1 = DB.show_path()
    path1 = path1[0][0]
    myWatcher = Watcher(path1)
    myWatcher.run()

    while True:  # 무한 루프를 통해 파일이 생성될때 화면 시그널이 1로 되며, 1이되면 화면을 띄워주는 함수로 간다.
        time.sleep(1)  # 1초 마다 대상 디렉토리 감시
        if myWatcher.temp == 1:
            myWatcher.Main()
        continue